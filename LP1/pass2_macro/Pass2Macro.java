import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Represents an entry in the Macro Name Table (MNT) for Pass 2.
 * Loaded from mnt.txt.
 */
class MNTEntryP2 {
    String macroName;
    int mdtIndex;
    int alaIndex;
    int positionalParams;
    int keywordParams;

    public MNTEntryP2(String macroName, int mdtIndex, int alaIndex, int positionalParams, int keywordParams) {
        this.macroName = macroName;
        this.mdtIndex = mdtIndex;
        this.alaIndex = alaIndex;
        this.positionalParams = positionalParams;
        this.keywordParams = keywordParams;
    }
}

/**
 * Represents an entry in the Macro Definition Table (MDT) for Pass 2.
 * Loaded from mdt.txt.
 */
class MDTEntryP2 {
    int index;
    String definitionLine;

    public MDTEntryP2(int index, String definitionLine) {
        this.index = index;
        this.definitionLine = definitionLine;
    }
}

/**
 * Represents an entry in the Argument List Array (ALA) for formal parameters for Pass 2.
 * Loaded from ala.txt.
 */
class ALAEntryP2 {
    int index;
    String parameterName;

    public ALAEntryP2(int index, String parameterName) {
        this.index = index;
        this.parameterName = parameterName;
    }
}

/**
 * Implements Pass 2 of a Macro Processor.
 * Reads Pass 1's output tables and the original assembly program
 * to perform macro expansion.
 */
public class Pass2Macro {

    // Tables loaded from Pass 1 output files
    private static Map<String, MNTEntryP2> MNT_P2 = new HashMap<>(); // MacroName -> MNTEntryP2
    private static List<MDTEntryP2> MDT_P2 = new ArrayList<>(); // List of MDTEntryP2
    private static List<ALAEntryP2> ALA_P2 = new ArrayList<>(); // List of ALAEntryP2 (formal parameters)

    public static void main(String[] args) {
        try {
            // Step 1: Load tables generated by Pass 1
            loadMNT("mnt.txt");
            loadMDT("mdt.txt");
            loadALA("ala.txt");

            // Step 2: Perform macro expansion
            expandMacros("macro_program.asm", "expanded_program.asm");

            System.out.println("Pass 2 Macro Processing completed successfully.");
            System.out.println("Expanded program written to expanded_program.asm");
        } catch (IOException e) {
            System.err.println("An error occurred during file operations: " + e.getMessage());
            e.printStackTrace();
        } catch (Exception e) {
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Loads the Macro Name Table (MNT) from the specified file.
     * @param filename The path to the mnt.txt file.
     * @throws IOException If an I/O error occurs.
     */
    private static void loadMNT(String filename) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            reader.readLine(); // Skip header line
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.trim().split("\\s+");
                if (parts.length >= 5) {
                    String macroName = parts[0];
                    int mdtIndex = Integer.parseInt(parts[1]);
                    int alaIndex = Integer.parseInt(parts[2]);
                    int positionalParams = Integer.parseInt(parts[3]);
                    int keywordParams = Integer.parseInt(parts[4]);
                    MNT_P2.put(macroName, new MNTEntryP2(macroName, mdtIndex, alaIndex, positionalParams, keywordParams));
                }
            }
        }
    }

    /**
     * Loads the Macro Definition Table (MDT) from the specified file.
     * @param filename The path to the mdt.txt file.
     * @throws IOException If an I/O error occurs.
     */
    private static void loadMDT(String filename) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            reader.readLine(); // Skip header line
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.trim().split("\\s+", 2); // Split only on first space
                if (parts.length == 2) {
                    int index = Integer.parseInt(parts[0]);
                    String definitionLine = parts[1];
                    MDT_P2.add(new MDTEntryP2(index, definitionLine));
                }
            }
        }
    }

    /**
     * Loads the Argument List Array (ALA) for formal parameters from the specified file.
     * @param filename The path to the ala.txt file.
     * @throws IOException If an I/O error occurs.
     */
    private static void loadALA(String filename) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            reader.readLine(); // Skip header line
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.trim().split("\\s+", 2); // Split only on first space
                if (parts.length == 2) {
                    int index = Integer.parseInt(parts[0]);
                    String parameterName = parts[1];
                    ALA_P2.add(new ALAEntryP2(index, parameterName));
                }
            }
        }
    }

    /**
     * Reads the original assembly program, performs macro expansion,
     * and writes the expanded code to an output file.
     * @param inputFilename The path to the original macro_program.asm file.
     * @param outputFilename The path for the generated expanded_program.asm.
     * @throws IOException If an I/O error occurs.
     */
    private static void expandMacros(String inputFilename, String outputFilename) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(inputFilename));
             FileWriter writer = new FileWriter(outputFilename)) {

            String line;
            boolean skipDefinition = false; // Flag to skip macro definition lines

            while ((line = reader.readLine()) != null) {
                String trimmedLine = line.trim();
                if (trimmedLine.isEmpty()) {
                    writer.write("\n"); // Preserve empty lines
                    continue;
                }

                String[] tokens = trimmedLine.split("\\s+");
                String firstToken = tokens[0].toUpperCase();

                if ("MACRO".equals(firstToken)) {
                    skipDefinition = true; // Start skipping lines until MEND
                    continue; // Do not write MACRO directive to output
                } else if ("MEND".equals(firstToken)) {
                    skipDefinition = false; // Stop skipping lines
                    continue; // Do not write MEND directive to output
                }

                if (skipDefinition) {
                    continue; // Skip lines that are part of a macro definition
                }

                // Check if the current line is a macro call
                if (MNT_P2.containsKey(firstToken)) {
                    // It's a macro call, expand it
                    MNTEntryP2 mntEntry = MNT_P2.get(firstToken);
                    expandMacroCall(mntEntry, tokens, writer);
                } else {
                    // Not a macro call, write the line directly to the output
                    writer.write(line + "\n");
                }
            }
        }
    }

    /**
     * Expands a single macro call.
     * @param mntEntry The MNTEntryP2 for the macro being called.
     * @param macroCallTokens The tokens of the macro call line (e.g., "INCR_REG BREG, 5").
     * @param writer The FileWriter to write the expanded code to.
     * @throws IOException If an I/O error occurs during writing.
     */
    private static void expandMacroCall(MNTEntryP2 mntEntry, String[] macroCallTokens, FileWriter writer) throws IOException {
        // Create an ALA for this specific macro invocation
        // This maps formal parameters (from ALA_P2) to actual parameters (from macroCallTokens)
        Map<String, String> invocationALA = new LinkedHashMap<>(); // Use LinkedHashMap to preserve order if needed

        // Extract actual parameters from the macro call
        String actualParamsString = "";
        if (macroCallTokens.length > 1) { // Check if there are operands
            // Combine all tokens after the macro name to get the full parameter string
            StringBuilder sb = new StringBuilder();
            for (int i = 1; i < macroCallTokens.length; i++) {
                sb.append(macroCallTokens[i]).append(" ");
            }
            actualParamsString = sb.toString().trim();
        }

        // Parse actual parameters, handling positional and keyword
        List<String> actualPositionalParams = new ArrayList<>();
        Map<String, String> actualKeywordParams = new HashMap<>();

        if (!actualParamsString.isEmpty()) {
            String[] params = actualParamsString.split(",");
            for (String param : params) {
                param = param.trim();
                if (param.contains("=")) {
                    String[] kv = param.split("=", 2);
                    actualKeywordParams.put(kv[0].trim().toUpperCase(), kv[1].trim());
                } else {
                    actualPositionalParams.add(param);
                }
            }
        }

        // Populate invocation ALA
        int positionalCount = 0;
        for (ALAEntryP2 formalParam : ALA_P2) {
            // Check if this formal parameter belongs to the current macro
            // This is a simplification; in a real system, ALA_P2 would be structured per macro,
            // or we'd use the alaIndex from MNT to find the relevant section.
            // For this simplified example, we'll rely on the order and counts.

            // Find the formal parameter name from ALA_P2 based on its index relative to this macro's ALA start
            int formalParamRelativeIndex = formalParam.index - mntEntry.alaIndex;
            if (formalParamRelativeIndex >= 0 && formalParamRelativeIndex < (mntEntry.positionalParams + mntEntry.keywordParams)) {
                if (formalParamRelativeIndex < mntEntry.positionalParams) {
                    // Positional parameter
                    if (positionalCount < actualPositionalParams.size()) {
                        invocationALA.put(formalParam.parameterName, actualPositionalParams.get(positionalCount));
                        positionalCount++;
                    } else {
                        // Positional parameter not provided, use default if available (not handled in this simplified ALA structure)
                        System.err.println("Warning: Positional parameter " + formalParam.parameterName + " not provided for macro " + mntEntry.macroName);
                        invocationALA.put(formalParam.parameterName, "MISSING_POS_PARAM");
                    }
                } else {
                    // Keyword parameter
                    String keywordFormalName = formalParam.parameterName.toUpperCase();
                    if (actualKeywordParams.containsKey(keywordFormalName)) {
                        invocationALA.put(formalParam.parameterName, actualKeywordParams.get(keywordFormalName));
                    } else {
                        // Keyword parameter not provided, use default value from MDT if available
                        // (Default values are stripped in Pass 1 ALA, so this needs MDT lookup or a more complex ALA)
                        System.err.println("Warning: Keyword parameter " + formalParam.parameterName + " not provided for macro " + mntEntry.macroName);
                        // For now, if default is not explicitly stored in ALA, we can't retrieve it easily.
                        // A robust solution would store default values in ALA or MNT.
                        invocationALA.put(formalParam.parameterName, "DEFAULT_VALUE_PLACEHOLDER"); // Placeholder
                    }
                }
            }
        }


        // Iterate through MDT from mdtIndex until MEND
        for (int i = mntEntry.mdtIndex; i < MDT_P2.size(); i++) {
            MDTEntryP2 mdtLine = MDT_P2.get(i);
            if ("MEND".equals(mdtLine.definitionLine)) {
                break; // End of macro definition
            }

            String expandedLine = mdtLine.definitionLine;

            // Replace (P,index) with actual parameters using invocationALA
            Pattern pattern = Pattern.compile("\\(P,(\\d+)\\)");
            Matcher matcher = pattern.matcher(expandedLine);
            StringBuffer sb = new StringBuffer();

            while (matcher.find()) {
                int paramIndex = Integer.parseInt(matcher.group(1));
                String actualParam = "UNKNOWN_PARAM"; // Default if not found

                // Find the formal parameter name corresponding to this index in ALA_P2
                String formalParamName = null;
                for (ALAEntryP2 alaEntry : ALA_P2) {
                    if (alaEntry.index == paramIndex) {
                        formalParamName = alaEntry.parameterName;
                        break;
                    }
                }

                if (formalParamName != null && invocationALA.containsKey(formalParamName)) {
                    actualParam = invocationALA.get(formalParamName);
                } else {
                    System.err.println("Error: Parameter index " + paramIndex + " not found in invocation ALA for macro " + mntEntry.macroName);
                }
                matcher.appendReplacement(sb, actualParam);
            }
            matcher.appendTail(sb);
            writer.write(sb.toString() + "\n");
        }
    }
}
